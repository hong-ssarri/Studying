# 논리 연산자
: 여러 가지 조건을동시에 검사할 때 사용하는 연산자
두 항의 값이 boolean 값일 때 연산 가능

## 논리 연산자의 종류
1. &&
2. ||
3. !

```java
boolean a = true;
boolean b = false;
boolean c = true;

System.out.println(a&&b);//false
System.out.println(a&&c);//true
System.out.println((2<4) && (4<5)); //true

System.out.println(a||b);//true
System.out.println(a||c);//true

System.out.println(!a);//false
```
_ _ _
# 비트 연산자
: 비트 단위로 연산을 하는 연산자

## 비트 연산자의 종류
- 비트 논리 연산자
- 비트 쉬프트 연산자

| 종류    | 연산자 | 사용예 | 설명                       |
|--------|-------|-------|----------------------------|
| 비트AND | &     | a&b   | a가 1이고 b가 1이면 결과 1   |
| 비트OR  | ｜    | a｜b   | a가 1이거나 b가 1이면 결과 1 |
| 비트XOR | ^     | a^b   | a와 b가 서로 다르면1 같으면0  |
| 비트NOT | ~     | ~a    | a가1이면 0, 0이면 1         |

> NOT 연산 공식
> * ~a = -a -1
>
> ~5 == -6?
> - - -
> 1. 왜 부호가 바뀌는가?
> 5: 0101(2)
> 편의상 5를 4bit로 표현한 것임
> 부호를 표현하는 비트: 부호비트 = 최상위 비트
> 부호비트 0: 양수
> 부호비트 1: 음수

_ _ _

비트에는 0 혹은 1이 올 수 있다

1: true
0: false
_ _ _

* 10 진수의 2진수 변환
	* 몫이 1이 될 때까지 나눈 후 거꾸로 올라오기
* 2진수의 10진수의 변환
	* 각 자리의 값이 1인 수를 2의 승으로 계산한 합
* 2진수의 덧셈연산
	* 0101(2) + 0110(2) ?

_ _ _

# 비트 쉬프트 연산자
: 쉬프트 연산 = 비트 이동 연산

## 비트 쉬프트 연산자의 종류
| 종류       | 연산자 | 사용예 | 설명                       |
|-----------|-------|-------|----------------------------|
| 왼쪽 쉬프트 | <<    | a<<n  | a의 비트를 왼쪽으로 n만큼 이동 |
| 오른쪽 쉬프트 | >>  | a>>n  | a의 비트를 오른쪽으로 b만큼 이동|

`오른쪽 쉬프트 연산자`
: 오른쪽으로 1칸씩 이동할 때마다 /2
15/2 = 7
7/2 = 3 (나머지는 버림)

`왼쪽 쉬프트 연산자`
: 왼쪽 1칸씩 이동할 때마다 *2
5*2 = 10
10*2 = 20
20*2 = 40
40*2 = 80769ㅐㅣ.6888ㅕ
_ _ _

* 15>>2 = 0011(2) = 3
15: 1111(2)

* 5<<4 = 0101 0000(2) = 80
5: 0101(2)